
## Chapter 1. 자료구조와 알고리즘

### 1) 자료구조란?

- **정의:** 컴퓨터에서 자료들을 정리하고 조직화하는 여러 가지 구조들
- **사용 목적:** 편리하고 효율적으로 사용하기 위해서 이용
- **분류:**

### 2) 알고리즘이란?

- **정의:** 어떤 문제를 해결하는 절차

    ex> 사전에서 단어 찾기

### 3) 프로그램 = 자료구조 + 알고리즘

- **자료구조:** 자료구조를 사용하여 표현되고 저장
- **알고리즘:** 주어진 문제를 처리하는 절차 즉, 알고리즘이 필요한다.
- 자료구조가 결정 → 그 자료구조에서 사용할 수 있는 알고리즘 결정
- **알고리즘의 조건:**
    1. 입력: 0개 이상의 입력이 존재하여야함
    2. 출력: 1개 이상의 출력이 존재하여야함
    3. 명백성: 각 명령어의 의미는 모호하지 않고 명확해야함
    4. 유한성: 한정된 수의 단계 후에는 반드시 종료되어야함
    5. 유효성: 각 명령어들은 실행 가능한 연산이어야함 (실행 불가 예시: 0으로 나누기)
- **알고리즘 기술 방법:**
    1. 영어나 한국어와 같은 자연어
    2. 흐름도
    3. 유사 코드
    4. 특정한 프로그래밍 언어

### 4) 추상 자료형

- **추상화:** "어떻게 sw시스템의 복잡성을 관리할 것인가?"에 대처하기 위해서 개발된 방법론의 핵심

    → 어떤 시스템의 간략화 된 기술 OR 명세로서 시스템의 정말 핵심적인 구조나 동작에만 집중하는 것

    ** 정보 은닉 기법

- **추상 자료형:** 추상화한 자료형, 즉 추상적으로 정의한 자료형

    → 자료의 집합과 자료에 가해지는 연산들의 집합에 대한 수학적인 명세(분명하고 자세한 내용)

     → 표현 순서: 

    1. 데이터를 정의
    2. 연산들을 정의

    → 추상 자료형을 컴퓨터 프로그램으로 구현할 떄는 보통 구현에 관한 세부사항들은 외부에서 모르게 하고 외부에는 간단한 인터페이스만들 공개함

    **→ 정보 은닉의 기본 개념 = 구현으로부터 명세의 분리**

    - 추상 자료형과 C++
        1. 추상 자료형의 개념 == 객체지향 개념
        2. C++에서는 클래스를 사용해서 추상 자료형 구현
        3. 추상 자료형의 데이터 == 속성(멤버 변수)
        4. 추상 자료형의 연산 == 메소드(멤버 함수)
        5. C++에서는 private이나 protected 키워드를 사용해서 속성과 연산에 대한 접근 제한 가능
        6. 클래스는 계층구조(상속)로 구성 가능

### 5) 알고리즘의 성능 분석

- 알고리즘의 효율이 중요한 이유:
    1. 프로그램의 규모가 이전에 비해서 커지고 있기 때문
    2. 사용자들은 여전히 빠른 프로그램 선호하기 때문
- 효율적인 알고리즘 = 전체 실행 시간이 짧고, 컴퓨터 자원(메모리 등)들을 적게 사용하는 알고리즘

    → 실행 시간 >> 메모리 공간 (중요도) → **알고리즘의 실행시간을 효율적인 알고리즘의 기준**

- 실행 시간 측정 방법:
    1. 실행 시간 측정

        → clock() 함수 이용:

        반환 단위 = CLOCKS_PER_SEC

        반환형 = clock_t형

        ```cpp
        #include <cstdio>
        #include <cstdlib>
        #include <ctime>

        void main(void){
        	clock_t start, finish;
        	double duration;
        	start = clock();
        	// 실행시간을 측정하고자 하는 코드
        	// 화면 출력문은 제외시켜야함에 유의!!
        	finish = clock();
        	duration = (double)(finish - start) / CLOCKS_PER_SEC;
        			printf("f 초입니다.\n", duration);
        }
        ```

        → 문제점:

        1. 2개의 알고리즘을 반드시 "구현"해야함
        2. 2개의 알고리즘을 반드시 동일한 조건의 하드웨어를 사용해서 실행해야함
        3. 사용한 소프트웨어 환경도 동일해야함
        4. 성능 비교에 사용했던 데이터가 아닌 다른 데이터에 대해서는 다른 결과가 나올 수 있음
    2. 알고리즘의 복잡도 분석

        → 알고리즘 분석에서 "좋다" == 실행 시간이 빠르고 처리를 위해 필요한 기억 공간이 적은 알고리즘

        → 용어:

        1. 시간 복잡도: 알고리즘의 실행 시간 분석

        2. 공감 복잡도: 알고리즘의 기억 공간 분석

        1) 시간 복잡도 함수:

        - 알고리즘을 이루고 있는 연산들이 몇 번이나 실행되는지를 숫자로 표시함
        - 복잡도 분석에 이들 연산의 실행횟수를 사용함
        - T(n) = 시간 복잡도 함수
        - T(n)의 최고차항의 영향이 n의 증가에 따라 점점 커져서 n=1000일 때는 전체의 약 99.9%

            → 시간 복잡도 분석에서 함수의 전체 항이 아니라 **최고차항만을 고려하면 됨**

        2) 빅오 표기법: 

        - 시간 복잡도 함수에서 불필요한 정보를 제거하여 알고리즘 분석을 쉽게 할 목적으로 시간 복잡도를 표시하는 방법
        - 장점: 시간 복잡도 함수의 증가에 별로 기여하지 못하는 항을 생략함으로써 시간 복잡도를 간단하게 표시할 수 있다
        - 방법: 다항식으로 표현되었을 경우 다항식의 최고차항만을 남기고 다른 항들과 상수항을 버림
        - 종류:
            1. O(1): 상수형
            2. O(log n): 로그형
            3. O(n): 선형
            4. O(nlogn): 선형 로그형
            5. O(n^2): 2차형
            6. O(n^3): 3차형
            7. O(2^n): 지수형
            8. O(n!): 팩토리얼형

            → O(1) < O(log n) < O(n) < O(nlogn) < O(n^2) < O(n^3) < O(2^n) < O(n!)

        3) 빅오 외의 표기법:

        1. 빅오메가
        2. 빅세타

## Chapter 2. 배열과 클래스

### 1) 배열

- 개념:

## Chapter 3. 스택

### 1) 스택이란?

- 스택: 자료의 입출력이 후입선출의 형태로 일어나는 자료구조
- 후입선출: (예시) 가장 최근에 설거지한 그릇이 가장 최근의 요리를 담는데 사용되는 것
- 특징:

    → 가장 먼저 입력된 데이터가 맨 아래에 쌓이고 가장 최근에 입력된 데이터가 가장 위에 쌓임

    → 입출력은 맨 위에서만 일어나고 스택의 중간에서는 데이터를 삽입하서나 삭제할 수 없다

- 용어:

    → 스택 상단: 스택에서 입출력이 이루어지는 부분

    → 스택 하단: 스택에서 바닥 부분

    → 요소: 스택에 저장되는 것

    → 공백: 스택에 요소가 하나도 없는 상태

    → 포화: 꽉 차서 요소를 더 이상 넣을 없는 상태

- 추상 자료형:

    **데이터:** 후입선출의 접근 방법을 유지하는 요소들의 모음

    **연산:**

    → push(x): 주어진 요소 x를 스택의 맨 위에 추가 (삽입)

    → pop(): 스택이 비어있지 않으면 맨 위에 있는 요소를 삭제하고 반환 (삭제)

    → isEmpty(): 스택이 비어있으면 true를 아니면 false를 반환

    → peek(): 스택이 비어있지 않으면 맨 위에 있는 요소를 삭제하지 않고 반환한다

    → isEmpty(): 스택이 가득 차 있으면 true를 아니면 false를 반환

    → size(): 스택 내의 모든 요소들의 개수를 반환

    → display(): 스택 내의 모든 요소들을 출력

    ** pop&isEmpty, push&isFull 같이

- 활용 예시:

    → 역순 만들기(되돌리기 기능)

    → 함수 호출

    → 활성화 레코드

    → 괄호 닫기가 정상적으로 되었는지 검사

    → 계산기 프로그램에서 수식 계산

    → 미로에서 출구 찾기

- 구현 방법:

    → 배열 / 연결 리스트 (2가지)로 구현 가능

    1. **배열 사용시,** 스택 ADT(추상 자료형)를 가장 간단하게 구현 가능 BUT 스택의 크기가 고정됨
    2. **연결 리스트 사용시,** 방법은 복잡 BUT 크기의 제한이 없는 유연한 리스트 구현 가능 (ifFull 필요X)

    → 일반 공책 = 배열, 바인더 공책 = 연결 리스트

- 구현 예시:

    ```cpp
    #include <cstdio>
    #include <cstdlib>

    inline void error(char *message){
        printf("%s\n", message);
        exit(1);
    }

    const int MAX_STACK_SIZE = 20;
    class ArrayStack{
        int top;
        int data[MAX_STACK_SIZE];

    public:
        ArrayStack() {top = -1;}
        ~ArrayStack(){}
        bool isEmpty(){return top == -1;}
        bool isFool() {return top == MAX_STACK_SIZE-1;}

        void push(int e){
            if(isFool()) error("스택 포화 에러");
            data[++top] = e;
        }

        int pop(){
            if(isEmpty()) error("스택 공백 에러");
            return data[top--];
        }

        int peek(){
            if(isEmpty()) error("스택 공백 에러");
            return data[top];
        }

        void display(){
            printf("[스택 항목의 수 = %2d] ==> ", top+1);
            for (int i=0; i<=top; i++)
                printf("<%2d>", data[i]);
            printf("\n");
        }
    };
    ```

    **<정리>**

    1. MAX_STACK_SIZE: 스택에 저장할 수 있는 최대 요소의 개수
    2. 스택이 처음 생성되면 top은 -1로 초기화됨 (index는 0부터 시작)
    3. push()로 추가되면 top+1 위치인 data[0]에 저장됨
    4. 공백 상태 & 포화 상태 검사

        → 공백 상태: top == -1

        → 포화 상태: top == MAX_STACK_SIZE - 1

    5. 삽입연산

        → isFull 연산을 이용해서 검사 후 스택이 가득 차 있다면,

        에러 메시지 출력

        → isFull 연산을 이용해서 검사 후 스택이 가득 차지 않았다면,

        새로운 항목 C를 스택에 삽입하면 C는 스택의 맨 위에 올라가고 top ++

    6. 삭제연산

        → isEmpty 연산을 이용해서 검사 후 스택이 공백이면,

        에러 메시지 출력

        → isEmpty 연산을 이용해서 검사 후 스택이 비어있지 않으면,

        top이 가리키는 값을 반환하고 top—

- ArrayStack의 설계 (클래스 다이어그램)
