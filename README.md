
## Chapter 1. 자료구조와 알고리즘

### 1) 자료구조란?

- **정의:** 컴퓨터에서 자료들을 정리하고 조직화하는 여러 가지 구조들
- **사용 목적:** 편리하고 효율적으로 사용하기 위해서 이용
- **분류:**

### 2) 알고리즘이란?

- **정의:** 어떤 문제를 해결하는 절차

    ex> 사전에서 단어 찾기

### 3) 프로그램 = 자료구조 + 알고리즘

- **자료구조:** 자료구조를 사용하여 표현되고 저장
- **알고리즘:** 주어진 문제를 처리하는 절차 즉, 알고리즘이 필요한다.
- 자료구조가 결정 → 그 자료구조에서 사용할 수 있는 알고리즘 결정
- **알고리즘의 조건:**
    1. 입력: 0개 이상의 입력이 존재하여야함
    2. 출력: 1개 이상의 출력이 존재하여야함
    3. 명백성: 각 명령어의 의미는 모호하지 않고 명확해야함
    4. 유한성: 한정된 수의 단계 후에는 반드시 종료되어야함
    5. 유효성: 각 명령어들은 실행 가능한 연산이어야함 (실행 불가 예시: 0으로 나누기)
- **알고리즘 기술 방법:**
    1. 영어나 한국어와 같은 자연어
    2. 흐름도
    3. 유사 코드
    4. 특정한 프로그래밍 언어

### 4) 추상 자료형

- **추상화:** "어떻게 sw시스템의 복잡성을 관리할 것인가?"에 대처하기 위해서 개발된 방법론의 핵심

    → 어떤 시스템의 간략화 된 기술 OR 명세로서 시스템의 정말 핵심적인 구조나 동작에만 집중하는 것

    ** 정보 은닉 기법

- **추상 자료형:** 추상화한 자료형, 즉 추상적으로 정의한 자료형

    → 자료의 집합과 자료에 가해지는 연산들의 집합에 대한 수학적인 명세(분명하고 자세한 내용)

     → 표현 순서: 

    1. 데이터를 정의
    2. 연산들을 정의

    → 추상 자료형을 컴퓨터 프로그램으로 구현할 떄는 보통 구현에 관한 세부사항들은 외부에서 모르게 하고 외부에는 간단한 인터페이스만들 공개함

    **→ 정보 은닉의 기본 개념 = 구현으로부터 명세의 분리**

    - 추상 자료형과 C++
        1. 추상 자료형의 개념 == 객체지향 개념
        2. C++에서는 클래스를 사용해서 추상 자료형 구현
        3. 추상 자료형의 데이터 == 속성(멤버 변수)
        4. 추상 자료형의 연산 == 메소드(멤버 함수)
        5. C++에서는 private이나 protected 키워드를 사용해서 속성과 연산에 대한 접근 제한 가능
        6. 클래스는 계층구조(상속)로 구성 가능

### 5) 알고리즘의 성능 분석

- 알고리즘의 효율이 중요한 이유:
    1. 프로그램의 규모가 이전에 비해서 커지고 있기 때문
    2. 사용자들은 여전히 빠른 프로그램 선호하기 때문
- 효율적인 알고리즘 = 전체 실행 시간이 짧고, 컴퓨터 자원(메모리 등)들을 적게 사용하는 알고리즘

    → 실행 시간 >> 메모리 공간 (중요도) → **알고리즘의 실행시간을 효율적인 알고리즘의 기준**

- 실행 시간 측정 방법:
    1. 실행 시간 측정

        → clock() 함수 이용:

        반환 단위 = CLOCKS_PER_SEC

        반환형 = clock_t형

        ```cpp
        #include <cstdio>
        #include <cstdlib>
        #include <ctime>

        void main(void){
        	clock_t start, finish;
        	double duration;
        	start = clock();
        	// 실행시간을 측정하고자 하는 코드
        	// 화면 출력문은 제외시켜야함에 유의!!
        	finish = clock();
        	duration = (double)(finish - start) / CLOCKS_PER_SEC;
        			printf("f 초입니다.\n", duration);
        }
        ```

        → 문제점:

        1. 2개의 알고리즘을 반드시 "구현"해야함
        2. 2개의 알고리즘을 반드시 동일한 조건의 하드웨어를 사용해서 실행해야함
        3. 사용한 소프트웨어 환경도 동일해야함
        4. 성능 비교에 사용했던 데이터가 아닌 다른 데이터에 대해서는 다른 결과가 나올 수 있음
    2. 알고리즘의 복잡도 분석

        → 알고리즘 분석에서 "좋다" == 실행 시간이 빠르고 처리를 위해 필요한 기억 공간이 적은 알고리즘

        → 용어:

        1. 시간 복잡도: 알고리즘의 실행 시간 분석

        2. 공감 복잡도: 알고리즘의 기억 공간 분석

        1) 시간 복잡도 함수:

        - 알고리즘을 이루고 있는 연산들이 몇 번이나 실행되는지를 숫자로 표시함
        - 복잡도 분석에 이들 연산의 실행횟수를 사용함
        - T(n) = 시간 복잡도 함수
        - T(n)의 최고차항의 영향이 n의 증가에 따라 점점 커져서 n=1000일 때는 전체의 약 99.9%

            → 시간 복잡도 분석에서 함수의 전체 항이 아니라 **최고차항만을 고려하면 됨**

        2) 빅오 표기법: 

        - 시간 복잡도 함수에서 불필요한 정보를 제거하여 알고리즘 분석을 쉽게 할 목적으로 시간 복잡도를 표시하는 방법
        - 장점: 시간 복잡도 함수의 증가에 별로 기여하지 못하는 항을 생략함으로써 시간 복잡도를 간단하게 표시할 수 있다
        - 방법: 다항식으로 표현되었을 경우 다항식의 최고차항만을 남기고 다른 항들과 상수항을 버림
        - 종류:
            1. O(1): 상수형
            2. O(log n): 로그형
            3. O(n): 선형
            4. O(nlogn): 선형 로그형
            5. O(n^2): 2차형
            6. O(n^3): 3차형
            7. O(2^n): 지수형
            8. O(n!): 팩토리얼형

            → O(1) < O(log n) < O(n) < O(nlogn) < O(n^2) < O(n^3) < O(2^n) < O(n!)

        3) 빅오 외의 표기법:

        1. 빅오메가
        2. 빅세타
